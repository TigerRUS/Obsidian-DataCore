#### Дать определение ОС. Указать цель, основные задачи ОС.
*ОС* – комплекс программ, предназначенных для эффективной организации вычислительного процесса в соответствии с заданным режимом выполнения программ, директивами программиста и указаниями пользователя.

*Цель ОС* – минимизация вмешательства человека в управление вычислительным процессом

*Задачи ОС:*
1. Управление устройствами
2. Управление процессами
3. Управление данными
4. Взаимодействие с пользователем
#### Дать определение прерывания, пояснить их назначение. Описать классификацию и общую схему обработки прерываний.
*Прерывание (Interrupt)* – оповещение процессора о событии, нуждающемся в приоритетной обработке.
Обработка прерывания влечёт за собой приостановку выполнения активной программы.
![[Pasted image 20231128202020.png]]
***Механизм прерываний***
происходит преревание
1) Процессор заканчивает выполнение текущей операции
2) В спец. структуру *сохраняются Instruction pointer, регистры и проч. информация* о прерванном процессе
3) На Instraction pointer помещается выполнение нового процесса
4) После выполнения процесса ранее прерванный процесс снова переходит в активное состояние (выполняется) благодаря сохранённой информации об этом процессе

![[Pasted image 20231128202200.png]]

#### Дать определение процесса, потока, задачи, ресурса и мультизадачности. Описать механизм переключения процессора с задачи на задачу. Описать отличие реализации потоков в пространстве ядра и в пространстве пользователя. Описать различия кооперативной и вытесняющей мультизадачности. Описать технологию гипертрейдинга.

*Процесс (Process)* – экземпляр программы, запущенной на выполнение (совокупность всех действий по исполнению программы процессором)
*Поток (Thread)* – часть контекста процесса (код + данные), связанная с решением определённой задачи

Процесс – инертная сущность, агрегатор потоков
Поток – единица исполнения

*Задача* – это абстракция описывающая выполняющую программу. Для ОС процесс представляет собой единицу работы.
*Ресурс* – объект в составе ВС, обладающий свойством полезности ВС – набор ресурсов
Процессы используют ресурсы, чтобы производить операции либо над ними, либо с их помощью

*Многозадачность (Multitasking)* – возможность ВС начать выполнение следующей задачи, ещё на закончив выполнение предыдущей.
![[Pasted image 20231208213316.png]]

![[Pasted image 20231128205536.png]]

![[Pasted image 20231128210412.png]]

![[Pasted image 20231208213453.png]]

*Реализация потока в ОС*
потоками управляет сам программист
*Реализация потока в пространстве пользователя*

**Кооперативная многозадачность** - 
тип многозадачности, при котором фоновые задачи выполняются только во время простоя основного процесса и только в том случае, если на это получено разрешение основного процесса.
**Вытесняющая многозадачность** - это вид многозадачности, при которой операционная система может временно прервать текущий процесс без какой-либо помощи с его стороны.
![[Pasted image 20231128210718.png]]

Ключевая идея технологии *Hyper-Threading* заключается в создании виртуальных ядер, которые дублируют некоторые физические ресурсы реальных ядер процессора.
Это позволяет процессору эффективнее использовать свои вычислительные ресурсы и более полно загружать каждое физическое ядро.
#### Дать определение процесса, ресурса, планировщика и приоритета. Описать уровни планирования. Охарактеризовать типы потоков с точки зрения планирования. Привести примеры планирования в ОС.**
*Процесс (Process)* – экземпляр программы, запущенной на выполнение (совокупность всех действий по исполнению программы процессором)
*Ресурс* – объект в составе ВС, обладающий свойством полезности ВС – набор ресурсов
Процессы используют ресурсы, чтобы производить операции либо над ними, либо с их помощью

![[Pasted image 20231208214152.png]]

*Планировщик задач* — программа (служба или демон), часто называемая сервисом операционной системы, которая запускает другие программы в зависимости от различных критериев, как, например: наступление определённого времени; переход операционной системы в определённое состояние.
*Приоритет* – числовая характеристика важности в системе.

![[Pasted image 20231208214218.png]]

![[Pasted image 20231208214404.png]]
#### Дать определение процесса, ресурса, планировщика и приоритета. Описать типы среды, в которой работает планировщик, а также соответствующие подходы к планированию.
![[Pasted image 20231208215603.png]]
![[Pasted image 20231208215505.png]]
![[Pasted image 20231208215534.png]]

#### Описать иерархию запоминающих устройств. Охарактеризовать статическое и динамическое распределение памяти, описать стек и кучу как основные механизмы управления памятью.

![[Pasted image 20231208224544.png]]
**Статическое выделение памяти** – выделение памяти, при котором размер выделяемой памяти известен ещё на этапе компиляции. При статическом выделении памяти операции выделения и освобождения памяти встраиваются в программу компилятором автоматически. Программисту достаточно лишь объявить переменную или массив, в этом же месте программы под неё будет выделена память.

**Динамическое выделение памяти** – выделение памяти в ходе работы программы, обычно используется в случаях, когда заранее неизвестен объём необходимой памяти. В случае динамического выделения памяти ответственность за выделение и освобождение памяти лежит на программисте. Неправильное выделение или освобождение памяти может привести к серьёзным последствиям вплоть до перезагрузки операционной системы (в некоторых ОС).
![[Pasted image 20231208224710.png]]
**Стек** — это область оперативной памяти, создаваемая для каждого потока. И последний добавленный в стек кусочек памяти и будет первым в очереди, то есть первым на вывод из стека. И каждый раз, когда функцией объявляется переменная, она, прежде всего, добавляется в стек. А когда данная переменная пропадает из нашей области видимости (к примеру, функция заканчивается), эта самая переменная автоматически удаляется из стека. При этом если стековая переменная освобождается, то и область памяти, в свою очередь, становится доступной и свободной для других стековых переменных.
*Размер стека* — это величина фиксированная, в результате чего при превышении лимита памяти, выделенной на стеке, произойдёт переполнение стека.
#### Описать механизм организации виртуальной памяти и основные стратегии подкачки. Описать средства, лежащие в основе механизма виртуальной памяти. Описать особенности размещения кода и данных для исполняемых файлов, а также библиотек с различными видами связывания.
**VRAM** - это ресурсы оперативной или внешней памяти, выделяемые прикладной программе операционной системой. Физическое расположение виртуальной памяти на реальных носителях может не совпадать с логической адресацией данных в прикладной программе. Преобразование логических адресов программы в физические адреса запоминающих устройств обеспечивается аппаратными средствами и операционной системой.

*Виртуальная память* (Virtual memory) представляет собой схему адресации памяти компьютера, при которой память представляется программному обеспечению непрерывной и однородной, в то время как в реальности, для фактического хранения данных, используются отдельные (разрывные) области различных видов памяти.

![[Pasted image 20231209101823.png]]
![[Pasted image 20231209101943.png]]

![[Pasted image 20231208225813.png]]
![[Pasted image 20231209102135.png]]

![[Pasted image 20231208225923.png]]
![[Pasted image 20231209103434.png]]
*MMU* - Блок управления памятью или устройство управления памятью — компонент аппаратного обеспечения компьютера, отвечающий за управление доступом к памяти, запрашиваемым центральным процессором

![[Pasted image 20231209110554.png]]
#### Описать основные виды организации памяти: стек, куча. Описать механизмы защиты памяти. Описать решение проблем утилизации памяти, предотвращения висячих ссылок и сбора мусора.

![[Pasted image 20231208230023.png]]
![[Pasted image 20231209112357.png]]

#### Описать основные механизмы межпроцессной коммуникации, предоставляемые операционной системой.

![[Pasted image 20231209113544.png]]
**основные механизмы**
![[Pasted image 20231209113633.png]]
![[Pasted image 20231209113659.png]]
![[Pasted image 20231209113740.png]]
![[Pasted image 20231209113807.png]]
![[Pasted image 20231209113840.png]]
![[Pasted image 20231209113850.png]]
![[Pasted image 20231209114004.png]]
![[Pasted image 20231209114015.png]]
![[Pasted image 20231211200113.png]]

===============================================================
![[Pasted image 20231211200039.png]]

#### Описать эталонную модель взаимодействия открытых систем (ISO OSI), пояснить, какие действия осуществляются на каждом из уровней.

![[Pasted image 20231209114200.png]]
Уровни
7) Самый нижний уровень. Он отвечает за обмен физическими сигналами между физическими устройствами, «железом». Устройства физического уровня оперируют битами
6) Далее уровень решает проблему адресации при передаче информации. Канальный уровень получает биты и превращает их в кадры (frame, также «фреймы»). Задача здесь — сформировать кадры с адресом отправителя и получателя, после чего отправить их по сети.
	На втором уровне OSI работают коммутаторы, их задача — передать сформированные кадры от одного устройства к другому, используя в качестве адресов только физические MAC-адреса. 
	На канальном уровне активно используется протокол ARP (Address Resolution Protocol — протокол определения адреса). С помощью него 64-битные MAC-адреса сопоставляются с 32-битными IP-адресами и наоборот, тем самым обеспечивается инкапсуляция и декапсуляция данных.
5) На 5-ом уровне появляется новое понятие — маршрутизация. Для этой задачи были созданы устройства третьего уровня — маршрутизаторы (их еще называют роутерами). Маршрутизаторы получают MAC-адрес от коммутаторов с предыдущего уровня и занимаются построением маршрута от одного устройства к другому с учетом всех потенциальных неполадок в сети.
4) Четвертый уровень — это посредник между Host Layers и Media Layers, относящийся скорее к первым, чем к последним. Его главной задачей является транспортировка пакетов. Естественно, при транспортировке возможны потери, но некоторые типы данных более чувствительны к потерям, чем другие. Например, если в тексте потеряются гласные, то будет сложно понять смысл, а если из видеопотока пропадет пара кадров, то это практически никак не скажется на конечном пользователе. Поэтому при передаче данных, наиболее чувствительных к потерям на транспортном уровне, используется протокол TCP, контролирующий целостность доставленной информации.
3) Пятый уровень оперирует чистыми данными. Помимо пятого, чистые данные используются также на шестом и седьмом уровне. Сеансовый уровень отвечает за поддержку сеанса или сессии связи. Пятый уровень оказывает услугу следующему: управляет взаимодействием между приложениями, открывает возможности синхронизации задач, завершения сеанса, обмена информации.
2) О задачах уровня представления вновь говорит его название. Шестой уровень отвечает за преобразование протоколов и кодирование/декодирование данных. Шестой уровень также занимается представлением картинок (в JPEG, GIF и т.д.), а также видео-аудио (в MPEG, QuickTime). А помимо этого → шифрованием данных, когда при передаче их необходимо защитить.
1) Седьмой уровень иногда еще называют уровень приложений, но чтобы не запутаться можно использовать оригинальное название — application layer. Прикладной уровень — это то, с чем взаимодействуют пользователи, своего рода графический интерфейс всей модели OSI, с другими он взаимодействует по минимуму.
#### Дать определение разделяемого ресурса, взаимного исключения, критической секции, условия гонки (Race Condition), тупика (Deadlock), активного тупика (Livelock), ресурсного голодания (Starvation). Привести примеры возникновения условия гонки и тупика, Блокировка шины.

**Разделение ресурса** — совместное использование несколькими процессами ресурса ВС, когда каждый из процессов некоторое время владеет ресурсом.

**Взаимное исключение** — свойство построения параллельных программ, которое используется в целях предотвращения состояния гонки. Оно требует, чтобы один поток исполнения никогда не входил в критическую секцию одновременно с тем, как другой параллельный поток выполнения вошел в свою критическую секцию.

**Критическая секция** — участок исполняемого кода программы, в котором производится доступ к общему ресурсу, который не должен быть одновременно использован более чем одним потоком исполнения.
 — блок кода, исполнение которого в условиях многозадачности может привести к условию гонки

![[Pasted image 20231213135339.png]]

![[Pasted image 20231213135813.png]]
![[Pasted image 20231213140128.png]]

![[Pasted image 20231213140241.png]]
![[Pasted image 20231213140335.png]]

![[Pasted image 20231213140532.png]]

![[Pasted image 20231213142703.png]]

#### Дать определение семафора, спинлока. Описать виды семафоров. Описать задачу читателя-писателя и привести решение этой задачи с применением семафоров.
![[Pasted image 20231213153957.png]]

![[Pasted image 20231213153922.png]]
![[Pasted image 20231213154140.png]]
![[Pasted image 20231213155121.png]]
![[Pasted image 20231213160603.png]]
![[Pasted image 20231213160546.png]]

#### Привести концептуальную реализацию бинарного семафора. Дать определение отношения предшествования процессов. Привести пример реализации отношения предшествования средствами семафоров.

**Отношение предшествования процессов** - означает, что первый процесс должен переходить в активное состояние всегда раньше второго

![[Pasted image 20231213155648.png]]

![[Pasted image 20231213155600.png]]
![[Pasted image 20231213155952.png]]

#### Описать основные средства синхронизации, предоставляемые современными операционными системами. В чём принципиальные отличия классического бинарного семафора, спинлока и мьютекса?

![[Pasted image 20231213155217.png]]
![[Pasted image 20231213155257.png]]
**1. Бинарный семафор:**
- Работает на основе блокировки и ожидания (когда процесс ожидает освобождения ресурса).
- Имеет два состояния: занят и свободен.
- Не имеет встроенного механизма предотвращения взаимоблокировки (deadlock), поэтому разработчику необходимо самому следить за этим.

**2. Спинлок:**
- Использует активное ожидание (процесс постоянно проверяет состояние ресурса, не ожидая уведомления о его освобождении).
- Не использует переключение контекста между потоками, что делает его быстрым в случае коротких ожиданий.
- Не подходит для ситуаций, когда поток должен длительно ожидать освобождения ресурса, так как это может привести к избыточному использованию процессорного времени.

**3. Мьютекс:**
- Использует блокировку и ожидание (поток блокируется и переходит в режим ожидания освобождения ресурса).
- Обеспечивает защиту от взаимоблокировки (deadlock) с помощью алгоритмов управления блокировкой.
- Имеет поддержку различных режимов блокировки (рекурсивная блокировка, отложенное освобождение и т.д.).
- Мьютексы обычно более гибкие и универсальные в сравнении с бинарными семафорами и спинлоками.

Таким образом, основные отличия между классическим бинарным семафором, спинлоком и мьютексом заключаются в подходе к обеспечению доступа к ресурсам, скорости и гибкости использования.

#### Дать определение монитора синхронизации, lock-free и wait-free объекта. В чём преимущества и недостатки мониторов по сравнению с семафорами? В чём преимущества и недостатки lock-free/wait-free объектов по сравнению с семафорами/мониторами? В каких случаях используются те и другие средства защиты ресурсов?

![[Pasted image 20231213160326.png]]

**Lock-free/wait-free объекты** - это структуры данных или алгоритмы, которые были разработаны таким образом, чтобы они не блокировали другие потоки выполнения в многопоточной среде.
*Lock-free* означает, что операции над объектами не используют блокировки, что позволяет другим потокам продолжать работу без задержек.
*Wait-free* означает, что каждый поток завершает выполнение операции в конечном счёте, независимо от того, выполнялись ли другие потоки параллельно или вообще остановились. Таким образом, lock-free/wait-free объекты обеспечивают высокую производительность и масштабируемость в многопоточных приложениях.

![[Pasted image 20231213160431.png]]

**Преимущества мониторов:**
1. Они обеспечивают управление доступом к ресурсам через объекты и методы, что упрощает код и делает его более читаемым.
2. Мониторы обеспечивают автоматическую блокировку и разблокировку ресурсов внутри методов, что делает код более надежным и предсказуемым.

**Недостатки мониторов:**
1. Встроенная блокировка может привести к проблемам с производительностью из-за возможной блокировки контекста выполнения.
2. Мониторы могут быть более сложными в использовании и внедрении, чем семафоры.

**Преимущества семафоров:**
1. Они обеспечивают более гибкий и настраиваемый доступ к ресурсам.
2. Семафоры более эффективны в управлении ресурсами, где требуется точное управление доступа.

**Недостатки семафоров:**
1. Они требуют явной блокировки и разблокировки ресурсов, что может привести к ошибкам и смешанным состояниям.
2. Семафоры могут делать код менее читабельным из-за использования явных вызовов блокировки и разблокировки.

*Lock-free/wait-free* объекты (или алгоритмы) обеспечивают более высокую степень параллелизма и меньшую вероятность блокировки контекста выполнения, чем мониторы и семафоры. Они используются в высокопроизводительных системах, где требуется максимальная эффективность и минимальная задержка.

Однако, lock-free/wait-free объекты также более сложны в реализации и требуют более аккуратного управления памятью и синхронизацией, что может делать их менее подходящими для простых систем или приложений.

В целом, мониторы и семафоры обычно используются в более традиционных приложениях, где требуется более простая и предсказуемая модель синхронизации, тогда как lock-free/wait-free алгоритмы используются в высокопроизводительных системах, где требуется максимальная производительность и параллелизм.
