![[image-5.png|352x274]]


**O(1) — Константное время**
Большинство операций в программе выполняются только раз или только несколько раз. Любой алгоритм, всегда требующий независимо от размера данных од ного и того же времени, имеет константную сложность.
- *Время выполнения не зависит от размера входных данных.* 
- Пример: доступ к элементу массива по индексу.
- Пример: очищения фиксированной части массива, независимо от его размеров.

**O(n) — Линейное время**
Время работы программы линейно, обычно, когда каждый элемент входных данных требуется обработать лишь линейное число раз, в данном случае имеет место линейная сложность.
- *Время выполнения растёт прямо пропорционально размеру входных данных.*  
- Пример: поиск элемента в массиве перебором всех элементов.
- Пример: для каждого входного данного производится одна операция

**O(log n) — Логарифмическое время**
Логарифмическая сложность, возникает в алгоритмах, в которых неоднократно подразделяет данные на подсписки. Такое время работы встречается обычно в программах, которые делят большую проблему в маленькие и решают их по отдельности.
- *Время выполнения растёт медленно при увеличении размера входных данных. Обычно встречается в алгоритмах, которые на каждом шаге делят задачу пополам.*  
- Пример: бинарный поиск в отсортированном массиве.
- Пример: работа с бинарными деревьями.

**O(n log n) — Линейно-логарифмическое время**
Логарифмическая сложность. Такое время работы имеют те алгоритмы, которые делят большую проблему в маленькие, а затем, решив их, соединяют их решения.
- *Время выполнения растёт чуть быстрее линейного, включает логарифмическое число операций для каждого элемента.*  
- Пример: сортировка массива быстрой сортировкой или сортировкой слиянием.

**O(n²) — Квадратичное время**
- *Время выполнения пропорционально квадрату размера входных данных.*  
- Пример: сортировка пузырьком, где сравниваются и при необходимости меняются местами все пары элементов.

**О(N^3), О(N^а) – Полиномиальная сложность**
- Пример: алгоритм Дейкстры - нахождение кратчайших путей в графе.

**O(2ⁿ) — Экспоненциальное время**
Такие алгоритмы чаще всего возникают в результате подхода, именуемого метод "грубой силы". Работа таких алгоритмов очень медленная и применима только при малых N. Эта сложность обычно связана с задачами, требующими неоднократного поиска дерева решений.
- *Время выполнения удваивается с каждым новым элементом во входных данных. Такие алгоритмы становятся непрактичными для больших входных размеров.*  
- Пример: генерация всех подмножеств множества.

**O(n!) — Факториальное время**
- *Время выполнения пропорционально факториалу размера входных данных.*  
- Пример: генерация всех перестановок множества.
- Пример: определения числа сочетаний, перестановок в комбинаторике.