**Полиморфизм** в C++ — это способность программы использовать объекты разных типов через единый интерфейс. Чаще всего под этим понимают *динамический (runtime) полиморфизм*, реализуемый через виртуальные функции.

**1. Суть и механизм (Virtual functions)**
Чтобы полиморфизм заработал, необходимо:
1. Наследование.
2. Виртуальные функции в базовом классе (`virtual`).
3. Обращение к объектам производных классов через **указатель** или **ссылку** на базовый класс.

```cpp
#include <iostream>
#include <vector>

class Car {
public:
    // Виртуальный деструктор обязателен! (см. нюансы)
    virtual ~Car() = default;

    // Виртуальная функция
    virtual void drive() const {
        std::cout << "Машина едет" << std::endl;
    }
};

class Tesla : public Car {
public:
    void drive() const override {
        std::cout << "Tesla едет бесшумно (автопилот)" << std::endl;
    }
};

class Ferrari : public Car {
public:
    void drive() const override {
        std::cout << "Ferrari ревет мотором" << std::endl;
    }
};

void startTrip(const Car& car) {
    car.drive(); // Вызовется нужный метод в зависимости от реального типа объекта
}

int main() {
    Tesla myTesla;
    Ferrari myFerrari;

    startTrip(myTesla);   // Выведет: Tesla едет...
    startTrip(myFerrari); // Выведет: Ferrari ревет...

    return 0;
}
```

**2. Спецификаторы `override` и `final`**
- [[override]]: Явно указывает, что функция должна замещать виртуальную функцию базового класса. Если вы ошибетесь в сигнатуре (например, забудете `const`), компилятор выдаст ошибку.
- [[final]]: Запрещает дальнейшее переопределение функции в наследниках или само наследование от класса.

```cpp
class SportCar : public Car {
public:
    void drive() const override final { // Дальше никто не переопределит
        std::cout << "Очень быстрая езда" << std::endl;
    }
};
```

**3. Абстрактные классы**
Если вы хотите запретить создание объекта базового класса и обязать наследников реализовать метод, используйте чисто виртуальную функцию (`= 0`).

```cpp
class AbstractCar {
public:
    virtual void refuel() = 0; // Чисто виртуальная функция
    virtual ~AbstractCar() = default;
};
```

**4. Нюансы и проблемы**
1. *Виртуальный деструктор (Критично!)*
Если в классе есть хотя бы одна виртуальная функция, деструктор обязан быть виртуальным.  
Проблема: Если удалить объект `Tesla` через указатель на `Car*`, а деструктор не виртуальный, вызовется только деструктор `Car`, и данные `Tesla` (например, память под батарею) не будут очищены. Это утечка памяти.

2. *Срез объектов (Object Slicing)*
Происходит, когда вы передаете объект по значению, а не по ссылке/указателю.
```cpp
void failDrive(Car car) { // Передача по значению!
    car.drive(); 
}
// Если передать Tesla, создастся копия только части Car, 
// и вызовется Car::drive(), а не Tesla::drive().
```

3. *Вызов виртуальных функций в конструкторе/деструкторе*
В C++ во время работы конструктора базового класса объект производного класса еще "не существует". Поэтому вызов `drive()` в конструкторе `Car` всегда вызовет `Car::drive()`, даже если мы создаем `Tesla`.

4. *Производительность*
Полиморфизм реализуется через таблицу виртуальных функций ([[vtable]]).
- Каждый объект хранит скрытый указатель (`vptr`) на таблицу.
- Это добавляет небольшие накладные расходы по памяти и небольшую задержку при вызове (косвенный переход).

Полиморфизм в C++ позволяет писать гибкий код (например, массив `std::vector<Car*>`), где каждый объект ведет себя по-разному, оставаясь в рамках одного интерфейса. Главное — всегда писать `virtual` деструктор и использовать `override`.

---
**1. Раннее связывание = Статический полиморфизм**
Этот вид полиморфизма реализуется на этапе компиляции. 
- Примеры: Перегрузка функций ([[overloading]]) и шаблоны ([[templates]]).
- Как это работает: Компилятор видит разные аргументы функции и еще до запуска программы «привязывает» вызов к конкретной реализации. 

**2. Позднее связывание = Динамический полиморфизм**
Этот вид полиморфизма проявляется во время выполнения программы (runtime). 
- Примеры: Виртуальные функции ([[virtual]]) и переопределение методов в наследниках ([[override]]).
- Как это работает: Программа решает, какой метод вызвать, только в момент самого вызова, основываясь на реальном типе объекта, на который указывает ссылка или указатель.