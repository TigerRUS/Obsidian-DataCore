```cpp
class DerivedSingleBase : [virtual] [access-specifier] Base
{
    // member list
};

class DerivedMultipleBases : [virtual] [access-specifier] Base1,
    [virtual] [access-specifier] Base2, ...
{
    // member list
};
```

*Наследование в C++* — это механизм, позволяющий создать новый класс (производный) на основе уже существующего (базового). Производный класс наследует атрибуты и методы базового класса, что позволяет повторно использовать код и выстраивать иерархии.

**1. Базовый синтаксис**
Для наследования используется оператор `:`, за которым следует спецификатор доступа и имя базового класса.
```cpp
#include <iostream>
#include <string>

// Базовый класс
class Car {
public:
    std::string brand = "Ford";
    void beep() {
        std::cout << "Beep beep!\n";
    }
};

// Производный класс
class Mustang : public Car {
public:
    std::string model = "Mustang";
};

int main() {
    Mustang myCar;
    myCar.beep(); // Метод из базового класса
    std::cout << myCar.brand << " " << myCar.model << std::endl;
    return 0;
}
```

**2. Спецификаторы доступа (Public, Protected, Private)**
- `public`: доступен всем.
- `protected`: доступен самому классу и его потомкам (производным классам), но закрыт для внешнего мира.
- `private`: доступен только внутри самого класса. Даже наследники не имеют к нему прямого доступа.

Тип наследования определяет максимальный уровень доступа для унаследованных членов в новом классе:

| Доступ в базе | `public` наследование  | `protected` наследование | `private` наследование |
| ------------- | ---------------------- | ------------------------ | ---------------------- |
| **public**    | становится `public`    | становится `protected`   | становится `private`   |
| **protected** | становится `protected` | становится `protected`   | становится `private`   |
| **private**   | недоступно             | недоступно               | недоступно             |
**Пример с защищенным доступом:**
```cpp
class Car {
protected:
    int engineHP = 300; // Наследники увидят, мейн — нет
};

class SportsCar : public Car {
public:
    void showHP() {
        std::cout << "Horsepower: " << engineHP; // Доступно здесь
    }
};
```

**3. Спецификаторы virtual и override**
При наследовании важно правильно переопределять функции.
- `virtual`: говорит о том, что функция может быть замещена в производных классах. Это необходимо для полиморфизма (чтобы через указатель на `Car` вызвался метод `Mustang`).
- `override`: (C++11) явно указывает, что вы переопределяете виртуальную функцию. Помогает избежать ошибок в сигнатуре.
- `final`: запрещает дальнейшее наследование класса или переопределение метода.

```cpp
class Car {
public:
    virtual void startEngine() { std::cout << "Generic engine start\n"; }
};

class ElectricCar : public Car {
public:
    void startEngine() override { std::cout << "Silent start\n"; }
};
```

**4. Ключевое слово friend (Друзья)**
Функция или класс, помеченные как `friend`, получают доступ к `private` и `protected` членам класса, даже если они не являются наследниками.

**Нюанс:** Дружба не наследуется. Если `Mechanic` - друг `Car`, он не становится автоматически другом `Mustang`

```cpp
class Car {
private:
    int safetyPin = 1234;
    friend class Mechanic; // Разрешаем доступ
};

class Mechanic {
public:
    void repair(Car& c) {
        c.safetyPin = 0000; // Доступ к private полю
    }
};
```

**5. Важные нюансы и порядок вызовов**

1. *Порядок конструкторов:* При создании объекта наследника сначала вызывается конструктор базового класса, затем — производного.
2. *Порядок деструкторов:* Строго обратный. Сначала отрабатывает деструктор производного, затем базового.
3. [[Виртуальный деструктор]]: Если в классе есть хотя бы одна виртуальная функция, *обязательно* делайте деструктор виртуальным (`virtual ~Car() = default;`). *Иначе при удалении объекта через указатель на базовый класс возникнет утечка памяти* (деструктор наследника не вызовется).
4. [[Множественное наследование]]: В C++ класс может наследоваться от нескольких классов сразу (`class Hybrid : public GasCar, public ElectricCar`). Это порождает проблему "Ромба" (Diamond Problem), которая решается виртуальным наследованием (`public virtual Car`).

- Используйте **public** наследование в 95% случаев (связь "является").
- Используйте **protected**, чтобы скрыть данные от пользователя, но оставить их доступными для подклассов.
- Всегда делайте **деструктор виртуальным** в базовых классах.
- Используйте **override**, чтобы компилятор ловил ошибки за вас.

---
**пример создания класса насследника в Qt**

```cpp
#include "adminpanel.h"
#include "ui_adminpanel.h"

AdminPanel::AdminPanel(QWidget *parent)
    : QWidget(parent) // Инициализация базового класса QWidget
    , ui(new Ui::AdminPanel) // Выделение памяти под объект интерфейса
{
    ui->setupUi(this);
    db = QSqlDatabase::database("MainConnection");

    if(!db.open())
    {
	    ...
    }
    else
    {
	    ...
    }
}

AdminPanel::~AdminPanel()
{
    delete ui;
}
```

- `: QWidget(parent)`: список инициализации ([[Member Initializer List]])
- `ui(new Ui::AdminPanel)`: Создается объект-оболочка, который хранит указатели на все элементы формы (например, `ui->pushButton`).
- `ui->setupUi(this)`: Эта функция берет все виджеты, описанные в дизайнере, и размещает их на текущем окне (`this`).