**Проблема «Ромба»** - без `virtual`
Если не использовать виртуальное наследование, объект `Hybrid` будет содержать два отдельных экземпляра `Car` (один от `GasCar`, другой от `ElectricCar`), что вызовет ошибку компиляции из-за неоднозначности.

```cpp
class Car {
public:
    int speed;
};

// Без virtual здесь будет копия Car
class GasCar : public virtual Car { };
class ElectricCar : public virtual Car { };

class Hybrid : public GasCar, public ElectricCar {
public:
    void setSpeed(int s) {
        speed = s; // Без virtual компилятор не поймет, чей speed: от GasCar или ElectricCar
    }
};
```

**Решение с виртуальным наследованием**
Ключевое слово `virtual` гарантирует, что в иерархии наследования будет существовать только один общий подобъект базового класса.

```cpp
#include <iostream>

class Car {
public:
    Car() { std::cout << "Car constructed\n"; }
    int speed;
};

// Виртуальное наследование
class GasCar : public virtual Car { };
class ElectricCar : public virtual Car { };

class Hybrid : public GasCar, public ElectricCar {
public:
    void setSpeed(int s) {
        // Теперь speed однозначен, так как Car только один
        speed = s;
    }
};

int main() {
    Hybrid myCar; // Конструктор Car вызовется только 1 раз
    myCar.setSpeed(100);
    std::cout << "Speed: " << myCar.speed << std::endl;
    return 0;
}
```

1. **Единственный экземпляр:** Благодаря `public virtual Car`, класс `Hybrid` содержит только одну копию полей класса `Car`.
2. **Снятие неоднозначности:** Обращение к `speed` внутри `Hybrid` теперь корректно, так как путь к нему через обоих родителей ведет к одному и тому же участку памяти.
3. **Инициализация:** В случае виртуального наследования ответственность за вызов конструктора `Car` ложится на «самый производный» класс (`Hybrid`), а не на промежуточных родителей.