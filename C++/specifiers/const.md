В C++ ключевое слово `const` (сокращение от _constant_) указывает компилятору, что объект или переменная не могут быть изменены после инициализации.

**Переменные**
Самый простой случай — создание неизменяемого значения.

```cpp
const int daysInWeek = 7;
// daysInWeek = 8; // Ошибка компиляции
```

**Указатели**
Здесь важно расположение `const`:

- **Указатель на константу:** нельзя изменить данные, на которые он указывает.
```cpp
const int* ptr = &daysInWeek; 
// *ptr = 10; // Ошибка
```

- **Константный указатель:** нельзя изменить адрес, который хранится в указателе.
```cpp
int x = 5;
int* const ptr = &x;
// ptr = &y; // Ошибка
```

**Параметры функций**

Использование `const` для передачи по ссылке предотвращает случайное изменение аргумента и позволяет передавать временные объекты (rvalues).

```cpp
void printMessage(const std::string& text) {
    // text = "new"; // Ошибка
    std::cout << text;
}
```


**Константные методы класса**

Если метод помечен как `const`, он обещает не изменять состояние объекта (поля класса). Только такие методы можно вызывать у константных объектов.

```cpp
class Player {
    int score;
public:
    int getScore() const { return score; } // OK
    void setScore(int s) { score = s; }    // Не может быть const
};
```

Ключевое слово [[mutable]]

Если поле класса помечено как `mutable`, его можно изменять даже внутри `const` методов. Это полезно для кэширования или счетчиков вызовов.

```cpp
mutable int accessCount = 0;
int getScore() const {
    accessCount++; // Разрешено для mutable
    return score;
}
```

`const` vs `constexpr`
- `const` — значение может быть вычислено во время выполнения (runtime), но после этого не меняется.
- `constexpr` — значение **обязательно** должно быть известно на этапе компиляции.

**Указатели на указатели (двойной const)**

Существует правило "чтения справа налево" для понимания сложных конструкций:

- `const int * const ptr` — константный указатель на константное целое (нельзя менять ни адрес, ни значение).

**Cast-снятие константности**

С помощью `const_cast` можно временно убрать ограничение константности, но изменение изначально константного объекта через такой хак ведет к Undefined Behavior ([[UB]]).