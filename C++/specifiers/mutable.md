Ключевое слово **`mutable`** в C++ используется для того, чтобы разрешить изменение поля объекта даже в тех случаях, когда сам объект помечен как `const` или доступ к нему осуществляется через константную ссылку.

Оно применяется к нестатическим полям данных класса. `mutable` говорит компилятору:
*Это поле может меняться всегда, даже внутри `const` методов*

Это полезно для реализации **логической константности**: когда объект внешне кажется неизменным (его состояние не меняется для пользователя), но внутренне ему нужно обновить вспомогательные данные.

Типичные случаи использования
1. **Кэширование:** сохранение результата тяжелых вычислений.
2. **Синхронизация:** использование `std::mutex` внутри константных методов.
3. **Счетчики/Статистика:** подсчет количества вызовов метода.

**Кэширование**
Представим класс, который вычисляет значение только один раз и запоминает его.
```cpp
#include <iostream>

class MathObject {
private:
    int value;
    // Помечаем поле как mutable, чтобы менять его в const методе
    mutable int cachedResult;
    mutable bool hasCache = false;

public:
    MathObject(int v) : value(v), cachedResult(0) {}

    // Метод помечен как const, он не должен менять "основное" состояние объекта
    int getExpensiveComputation() const {
        if (!hasCache) {
            std::cout << "Выполняем сложные вычисления..." << std::endl;
            cachedResult = value * 42; // Это было бы невозможно без mutable
            hasCache = true;
        }
        return cachedResult;
    }
};

int main() {
    const MathObject obj(10); // Константный объект
    std::cout << obj.getExpensiveComputation() << std::endl; // Первый вызов (вычисляет)
    std::cout << obj.getExpensiveComputation() << std::endl; // Второй вызов (берет из кэша)
    return 0;
}
```

**Мьютексы (std::mutex)**
Мьютексы почти всегда объявляются как `mutable`, потому что методы чтения данных `get` обычно помечены как `const`, но им все равно нужно захватывать мьютекс `lock()`, что технически меняет состояние мьютекса.

```cpp
#include <mutex>

class ThreadSafeCounter {
private:
    int counter = 0;
    mutable std::mutex mtx; // Позволяет делать lock() в константных методах

public:
    int getCount() const {
        std::lock_guard<std::mutex> lock(mtx); // Изменяет внутреннее состояние mtx
        return counter;
    }
};
```

- `mutable` нельзя использовать с полями, объявленными как `static` или `const`.
- Использование `mutable` — это сигнал разработчику, что данное поле не влияет на видимое извне состояние объекта.
- В лямбда-выражениях `mutable` позволяет изменять переменные, захваченные по значению.