спецификатор `final` (появившийся в стандарте C++11) используется для двух целей: запрета наследования от класса и запрета переопределения виртуальной функции в производных классах.

**1. final для классов**
Если класс помечен как `final`, от него *нельзя наследоваться*. Это полезно для оптимизации (компилятор может применить девиртуализацию) и для обеспечения логической завершенности архитектуры.

```cpp
class Base final { 
    // Класс помечен как окончательный
};

// Ошибка компиляции: нельзя наследоваться от 'Base'
class Derived : public Base { 
};
```

**2. final для виртуальных функций**
Если виртуальная функция помечена как `final`, её **нельзя переопределять** в классах-наследниках. При этом сам класс остается доступным для наследования.

```cpp
class Parent {
public:
    virtual void display() const {
        // Какая-то логика
    }
};

class Child : public Parent {
public:
    // Помечаем, что в дальнейших подклассах эту функцию менять нельзя
    void display() const override final {
        // Новая логика
    }
};

class GrandChild : public Child {
public:
    // Ошибка компиляции: переопределение 'display' запрещено спецификатором final
    void display() const override {
    }
};
```

Зачем это нужно?
1. **Безопасность архитектуры:** Вы явно указываете другим разработчикам, что логика данного класса или метода не должна меняться.
2. **Производительность:** Когда компилятор видит `final`, он понимает, что вызывать функцию через таблицу виртуальных методов (vtable) не обязательно, так как наследников с другой реализацией быть не может. Это позволяет сделать вызов функции прямым и более быстрым.