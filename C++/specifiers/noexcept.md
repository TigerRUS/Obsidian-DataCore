Спецификатор **`noexcept`** в C++ используется для указания того, может ли функция выбрасывать исключения. Это помогает компилятору оптимизировать код и повышает безопасность программы.

**1. Основные значения**
- `noexcept` (или `noexcept(true)`): функция гарантирует, что не выбросит исключение. Если исключение всё же вылетит из такой функции, программа немедленно завершится через вызов `std::terminate()`.
- `noexcept(false)`: функция может выбрасывать исключения (поведение по умолчанию для большинства функций).

**2. Зачем это нужно?**
1. **Оптимизация**: Если компилятор знает, что исключений не будет, он может не генерировать сложный код для «разкрутки стека» (stack unwinding).
2. **Эффективность контейнеров**: Такие контейнеры, как `std::vector`, при изменении размера используют **перемещение** (`move`) вместо копирования только в том случае, если конструктор перемещения помечен как `noexcept`. Это предотвращает потерю данных при ошибке.

```cpp
void fastFunction() noexcept {
    // Я гарантирую, что здесь не будет throw
}

void riskyFunction() {
    throw std::runtime_error("Ошибка!");
}
```

`noexcept` также работает *как логический оператор, который проверяет выражение на этапе компиляции*.
```cpp
void test() {
    bool canThrow = noexcept(riskyFunction()); // false
    bool safe = noexcept(fastFunction());      // true
}
```

Реальный профит (Move-конструктор):
```cpp
class MyClass {
public:
    // Без noexcept vector будет копировать объекты, что медленно.
    // С noexcept vector будет их перемещать, что быстро.
    MyClass(MyClass&& other) noexcept {
        // Логика перемещения
    }
};
```

Используйте `noexcept` для:
- Конструкторов перемещения и операторов присваивания перемещением.
- Деструкторов (они `noexcept` по умолчанию в C++11 и выше).
- Функций, в которых вы абсолютно уверены, что ошибки невозможны или фатальны.