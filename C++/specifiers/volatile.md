`volatile` в C++ — это ключевое слово (квалификатор типа) *volatile - Изменчивый*, которое сообщает компилятору, что *значение переменной может быть изменено в любой момент внешними силами, такими как аппаратное обеспечение, другой поток или процедура прерывания*. Это запрещает компилятору проводить определенные оптимизации для этой переменной, гарантируя, что каждое обращение к ней будет читать или записывать значение непосредственно из памяти, а не из кэша регистра.  

Зачем использовать `volatile`
- **Предотвращение ошибок компиляции**: 
    При работе с переменными, которые могут меняться асинхронно, компилятор может оптимизировать код таким образом, что это приведет к неверным результатам. Например, компилятор может сохранить значение переменной в регистре и использовать его много раз, а не обращаться каждый раз к памяти, если не видит изменений в коде. 
- **Взаимодействие с аппаратным обеспечением**: 
    Например, при работе с устройствами ввода-вывода, отображаемыми в памяти, или при обработке прерываний, значение переменной может быть изменено аппаратурой или кодом прерывания. `volatile` гарантирует, что код будет считывать актуальное значение переменной. 
- **Работа с потоками**: 
    При использовании нескольких потоков программы, `volatile` гарантирует, что компилятор не будет кэшировать значение переменной в регистре, а будет читать его из памяти при каждом обращении. Это важно для корректного взаимодействия между потоками. 
    
Пример использования
```cpp
#include <iostream>// Переменная, значение которой может меняться внешними силами
volatile int flag = 0;

void interrupt_handler() {
    flag = 1; // Изменение переменной извне (например, в обработчике прерывания)
}

int main() {
    while (flag == 0) {
        // В бесконечном цикле, компилятор может оптимизировать
        // и кэшировать значение flag в регистре.        // Если flag никогда не меняется, цикл станет бесконечным.
        // Используя volatile, мы гарантируем, что значение flag
        // будет проверяться каждый раз из памяти.    }    std::cout << "Цикл прерван!" << std::endl;    return 0;}
```

**оптимизация кода компилятором**
```cpp
int ar[1024];for(size_t i = 0; i < 1024; i++)
{
	ar[i] = ...;
}
```

Самая затратная операция в этом примере не присваивание ячейке массива какого-либо значения и не инкремент счетчика, а именно операция сравнения, поэтому компилятор оптимизирует это примерно вот так:  
```cpp
int ar[1024];
for(size_t i = 0; i < 1024 / 4; i += 4)
{
	ar[i] = ...;
    ar[i + 1] = ...;
    ar[i + 2] = ...;
    ar[i + 3] = ...;
}
```

Еще очень простой пример, в котором имеем массив символов, с помощью цикла проходим по всей строке и выполняем какие-то действия с символами:  
```cpp
сhar str[125];
for(size_t i = 0; i < strlen(str); i++)
{
	...
}
```

В этом случае компилятор вынесет вызов `strlen()` в отдельную переменную:  
```cpp
сhar str[125];
size_t length = strlen(str);
for(size_t i = 0; i < lenght; i++)
{
    ...
}
```

Также чтобы не писать код, так как он очевиден, компилятор заменяет умножение на 2, сложением, но и пожалуй самый главный пример по нашей тематике, это то, что в большинстве случаев компилятор разгружает runtime программы, путем подстановки в выражения уже их значения, к примеру мы пишем программу для лифта. Одно из условий данной программы таково, что как только зайдут к примеру больше 4 человек должно выдаться предупреждение.  
  
```cpp
const MAX_COUNT_PEOPLE = 4;
size_t countPeole = 0;
...
if(countPeople > MAX_COUNT_PEOPLE)
{
    // Выдаем предупреждение
}
// Значение переменной countPeople к примеру будет менять с другого потока
```

Все же хорошо, ошибки невозможны в этом коде. Но по сути условие будет всегда истинно, так как компилятор уже запомнил значения этих переменных. И вот как раз таки в таких случаях применяется ключевое слово `volatile`, чтобы избежать подобных казусов, это будет выглядеть вот так:  
  
```cpp
const MAX_COUNT_PEOPLE = 4;
volatile size_t countPeole = 0;
...
if(countPeople > MAX_COUNT_PEOPLE){
    // Выдаем предупреждение
}
// Значение переменной countPeople к примеру будет менять с другого потока
```