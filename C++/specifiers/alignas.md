Спецификатор `alignas` в C++ (введен в C++11) используется для [[Выравнивание памяти]]

Каждый тип данных имеет естественное выравнивание (например, `int` обычно выравнивается по 4 байтам). `alignas` позволяет вручную увеличить это значение, чтобы *объект начинался с адреса, кратного заданному количеству байт*.

Это критично для:
1. Использования **SIMD-инструкций** (SSE, AVX), которые требуют выравнивания по 16, 32 или 64 байта.
2. Исключения **false sharing** (ложного разделения) в многопоточности (выравнивание по размеру кэш-линии, обычно 64 байта).
3. Работы со специфическим оборудованием или DMA.

```cpp
alignas(16) int x; // Переменная x будет выровнена по границе 16 байт
alignas(double) char c; // Выровнять char так же, как double
```

В данном примере мы создаем структуру, которая будет занимать целую кэш-линию, чтобы избежать проблем с производительностью в многопоточной среде.

```cpp
#include <iostream>

struct alignas(64) CacheLineAligned {
    int value;
};

struct DefaultAligned {
    int value;
};

int main() {
    CacheLineAligned a;
    DefaultAligned b;

    std::cout << "Alignment of a: " << alignof(decltype(a)) << " bytes\n";
    std::cout << "Alignment of b: " << alignof(decltype(b)) << " bytes\n";

    return 0;
}
```

Важные правила:
1. **Нельзя уменьшить**: `alignas` нельзя использовать для того, чтобы сделать выравнивание меньше стандартного для этого типа.
2. **Аргумент**: В качестве аргумента можно передавать целое число (степень двойки) или тип данных.
3. **Где применять**: Можно применять к переменным, членам данных класса или при объявлении самого класса/структуры.
4. **Проверка**: Для получения текущего выравнивания типа используется оператор `alignof`.
