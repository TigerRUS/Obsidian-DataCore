**rvalue-ссылка** (обозначается как `&&`) — это тип ссылки в C++, который может привязываться только к временным объектам (rvalue).

Главная цель — **оптимизация производительности** за счет двух механизмов:
1. **Move-семантика (Перемещение):** Вместо дорогого копирования данных (например, из огромного массива) мы просто «забираем» владение ресурсом у временного объекта, который всё равно сейчас будет удален
2. **Perfect Forwarding (Идеальная передача):** Позволяет передавать аргументы в другие функции без потери их свойств (lvalue останется lvalue, rvalue — rvalue)

Пример: Move-семантика
Представьте класс, который хранит массив в динамической памяти.

```cpp
#include <iostream>
#include <vector>

class MyBuffer {
public:
    int* data;
    size_t size;

    // Конструктор
    MyBuffer(size_t s) : size(s), data(new int[s]) {}

    // 1. Конструктор копирования (дорого: выделяем память, копируем цикл)
    MyBuffer(const MyBuffer& other) : size(other.size), data(new int[other.size]) {
        for (size_t i = 0; i < size; ++i) data[i] = other.data[i];
        std::cout << "Copy Constructor\n";
    }

    // 2. Move-конструктор (дешево: просто забираем указатель)
    MyBuffer(MyBuffer&& other) noexcept : data(other.data), size(other.size) {
        other.data = nullptr; // Обязательно зануляем, чтобы деструктор 'other' не удалил данные
        other.size = 0;
        std::cout << "Move Constructor\n";
    }

    ~MyBuffer() { delete[] data; }
};

int main() {
    std::vector<MyBuffer> vec;
    
    // Создаем временный объект. Благодаря rvalue-ссылке сработает Move-конструктор.
    // Данные не будут копироваться, они просто "переедут" в вектор.
    vec.push_back(MyBuffer(1000000)); 
    
    return 0;
}
```

Краткое резюме
- **lvalue** — это именованный объект (то, что имеет адрес в памяти).
- **rvalue** — это временный объект, результат выражения или литерал (то, у чего нет имени)
- `std::move` — это функция, которая принудительно превращает *lvalue* в *rvalue*, позволяя «переместить» данные из обычного объекта