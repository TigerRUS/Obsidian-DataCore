В C++ виртуальный деструктор используется для *правильного освобождения памяти при удалении объекта через указатель на базовый класс*.
Если базовый класс имеет виртуальный деструктор, то *при удалении объекта через указатель на базовый класс будет вызван деструктор не только базового класса, но и всех его производных классов*. Это позволяет избежать утечек памяти и неопределенного поведения при работе с полиморфными объектами.

Если *виртуального деструктора не объявлено в базовом классе*, то при удалении производного объекта через указатель на базовый класс *будут вызваны только деструкторы базового класса*, что может привести к утечкам памяти и неопределенному поведению.

```cpp
#include <iostream>

using namespace std;

struct Base
{
   Base() { cout <<  "Base()" << endl; }
   ~Base(){ cout << "~Base()" << endl; }
};

struct Derived: public Base
{
   Derived() { cout <<  "Derived()" << endl; }
   ~Derived(){ cout << "~Derived()" << endl; }
};

int main()
{
   Base* obj = new Derived();
   delete obj;
}
```

Что вы могли ожидать на выходе:
```cpp
Base()
Derived()
~Derived()
~Base()
```

Что может произойти (может, потому что, в общем случае, это *undefined behaviour*
```cpp
Base()
Derived()
~Base()
```

Для устранения данной проблемы необходимо деструктор класса родителя объявить виртуальным (`virtual ~Base()`), что позволит компилятору добраться до деструктора наследника по *таблице виртуальных функций* ([[vtable]]).