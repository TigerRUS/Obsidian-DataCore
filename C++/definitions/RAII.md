**RAII (Resource Acquisition Is Initialization)** - "Получение ресурса есть инициализация" — это ключевая идиома C++, которая связывает жизненный цикл ресурса (памяти, файла, мьютекса) с жизненным циклом объекта. Ресурс захватывается в конструкторе объекта, а освобождается в деструкторе, гарантируя автоматическое и безопасное управление ресурсами даже при возникновении исключений.

Пример с умными указателями:
```c++
#include <memory>
#include <iostream>

struct Foo {
    Foo() { std::cout << "Init\n"; }
    ~Foo() { std::cout << "Destroy\n"; }
};

void bar() {
    std::unique_ptr<Foo> p = std::make_unique<Foo>(); // RAII
    // делаем что-то
} // тут автоматически вызовется ~Foo()
```

Что важно знать:
* `std::unique_ptr` — владение в единственном числе, идеально для большинства случаев.
* `std::shared_ptr` — разделённое владение (но дороже по производительности).
* Никогда не делай `new` без обёртки — почти всегда лучше `std::make_unique` или `std::make_shared`.

Примеры
- **`std::vector`, `std::string`:** Управляют памятью, выделяя ее при создании и освобождая при уничтожении объекта.
- **`std::unique_ptr`, `std::shared_ptr`:** Умные указатели, которые владеют динамически выделенной памятью и освобождают ее, когда становятся ненужными.
- **`std::lock_guard` (для мьютексов):** Блокирует мьютекс в конструкторе и разблокирует его в деструкторе

*RAII* работает не только для памяти: файлы, мьютексы, сокеты — всё. Достаточно обернуть ресурс в класс с деструктором.