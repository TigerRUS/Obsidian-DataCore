Старый добрый *new / delete* — это классика, но и источник утечек, крашей и боли. В современном C++ ручное управление памятью почти всегда антипаттерн.

Решение — *RAII (Resource Acquisition Is Initialization)*: ресурсы живут ровно столько, сколько объект, который ими владеет. Ушёл объект из области видимости — ресурс освободился.

Пример с умными указателями:
```c++
#include <memory>
#include <iostream>

struct Foo {
    Foo() { std::cout << "Init\n"; }
    ~Foo() { std::cout << "Destroy\n"; }
};

void bar() {
    std::unique_ptr<Foo> p = std::make_unique<Foo>(); // RAII
    // делаем что-то
} // тут автоматически вызовется ~Foo()
```

Что важно знать:
* `std::unique_ptr` — владение в единственном числе, идеально для большинства случаев.
* `std::shared_ptr` — разделённое владение (но дороже по производительности).
* Никогда не делай `new` без обёртки — почти всегда лучше `std::make_unique` или `std::make_shared`.

*RAII* работает не только для памяти: файлы, мьютексы, сокеты — всё. Достаточно обернуть ресурс в класс с деструктором.