В C++ все выражения делятся на категории в зависимости от того, как они работают с памятью. Основные из них — **lvalue** и **rvalue**.

Что такое rvalue?

**rvalue** (от _right value_) — это временное значение, которое не имеет постоянного адреса в памяти и обычно находится в правой части оператора присваивания.

- **Суть:** Это «одноразовые» объекты, которые исчезают сразу после использования.
- **Где хранятся:** Часто только в регистрах процессора или во временных стековых кадрах.
- **Свойство:** У rvalue нельзя взять адрес с помощью оператора `&`.

Примеры rvalue
1. **Литералы:** (кроме строковых)
```cpp
int x = 10; // 10 — это rvalue
```

2. **Результаты арифметических операций:**
```cpp
int x = 5 + 5; // (5 + 5) — это rvalue. У результата "10" нет имени или адреса.
```

3. **Временные объекты, возвращаемые функциями по значению:**
```cpp
std::string getName() { return "Ivan"; }

// Результат getName() — это rvalue. 
// Он будет уничтожен сразу после выполнения строки.
std::string s = getName(); 
```

4. **Явное создание временного объекта:**
```cpp
std::vector<int>({1, 2, 3}); // Этот безымянный вектор — rvalue
```

|Характеристика|lvalue (left value)|rvalue (right value)|
|---|---|---|
|**Что это?**|Объект с именем (переменная)|Временное значение|
|**Адрес**|Можно взять адрес (`&obj`)|Нельзя взять адрес|
|**Время жизни**|До конца области видимости|Мгновенное (до конца выражения)|
|**Пример**|`int x;`, `obj.field`, `*ptr`|`42`, `x + y`, `MyClass()`|

*Зачем это нужно? (rvalue-ссылки)*
В современном C++ (начиная с C++11) появились [[rvalue-ссылки]], которые записываются как `&&`. Они позволяют «захватывать» временные объекты, чтобы не копировать их данные, а перемещать их (*Move Semantics*).

**Пример с rvalue-ссылкой:**
```cpp
int&& ref = 10 + 5; // Правильно: rvalue-ссылка продлевает жизнь временному значению
// int& ref = 10 + 5; // ОШИБКА: обычная lvalue-ссылка не может указывать на rvalue
```

**Итог:** rvalue — это «расходный материал» программы. Понимание rvalue критически важно для написания эффективного кода с использованием перемещения данных вместо дорогого копирования.