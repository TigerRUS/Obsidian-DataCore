Кажется, что ```
```c++
std::vector<bool>
```
— обычный вектор из bool. Но на самом деле это не так.
```
Под капотом vector<bool> хранит биты плотно упакованными (1 бит на элемент), а не как bool (обычно 1 байт). Из-за этого:
- Элемент — это не bool&, а прокси-объект (std::vector<bool>::reference).
- Нельзя получить настоящий указатель на элемент: &v[0] не даст bool*.
- Код работает медленнее из-за лишней возни с битовыми масками.
```
Пример неожиданности:
```c++
std::vector<bool> v{true, false};
auto p = &v[0]; // Ошибка! Нет bool*
```

Хотите реально быстрый и предсказуемый контейнер?

Используйте `std::vector<char>` или `std::vector<uint8_t>` для хранения флагов.
Или подключите `boost::dynamic_bitset`, если нужна именно битовая упаковка.

На первый взгляд `std::vector<bool>` — обычный вектор, только из булевых значений. Но это особенный шаблон. Вместо хранения `bool` как полноценного байта, он упаковывает их в биты. Экономит память? Да. Но есть нюансы.

Пример:
```c++
std::vector<bool> flags = {true, false, true};
auto x = flags[0];        // Не bool, а прокси-объект!
bool y = flags[0];        // OK — копия значения
bool& z = flags[0];       // Ошибка компиляции
```

`flags[0]` возвращает *proxy-объект*, а не `bool&`, потому что нельзя вернуть ссылку на бит. Из-за этого:
* Нельзя взять адрес элемента
* Нельзя использовать `std::vector<bool>` с API, ожидающим `bool*` или `bool&`

Хочешь экономии — будь готов к сюрпризам. Хочешь предсказуемости — используй `std::deque<bool>` или `std::vector<char>`.

`std::vector<bool>` — единственная специализация STL-контейнера в стандартной библиотеке.
