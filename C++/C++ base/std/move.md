Многие знают про `std::move,` но не всегда используют его там, где это реально ускоряет код. Простой пример — возврат локального объекта из функции:

```c++
#include <string>

std::string make_string() {
    std::string s = "Hello";
    return s; // RVO или move
}
```

С C++17 тут почти всегда [[RVO]] (Return Value Optimization). Но если RVO невозможен (например, возвращаем тернарный оператор), компилятор применит move:

```c++
std::string make_string(bool flag) {
    std::string a = "foo", b = "bar";
    return flag ? a : b; // тут будет move
}
```

А вот так можно подсказать компилятору явно:

```c++
return std::move(flag ? a : b);
```

Но осторожно: не делайте `std::move` для локальной переменной в простом `return` — это может сломать [[RVO]] и привести к лишнему перемещению.

Ещё полезно помнить: move не всегда бесплатный. Например, для `std::vector` он копирует указатель и размер, но не элементы. Для `std::string` — зависит от [[SSO]] *(Small String Optimization: короткие строки перемещаются как копия)*.

Вывод: используйте `std::move` там, где явно хотите отдать объект, а не копировать. Но не злоупотребляйте им: компилятор с C++17 сам неплохо справляется.

**Почему std::move может не сработать**
Многие думают, что `std::move` всегда приводит к перемещению. Но это не так. `std::move` не двигает — он просто превращает объект в *rvalue-ссылку*. Всё остальное — за перегрузками.

Вот ловушка:
```c++
void take(std::string s) {
    // s — копия, даже если передавали std::move
}

std::string str = "hello";
take(std::move(str)); // копирование, не перемещение
```

Почему? Потому что take принимает по значению, а значит, всегда делает копию. Даже если ты передал `std::move(str)`, она скопируется в `s`. Чтобы работало перемещение, нужна *rvalue-ссылка*:
```c++
void take(std::string&& s) {
    // теперь s — это rvalue-ссылка
}
```

Но даже тут можно облажаться:
```c++
void take(std::string&& s) {
    process(s); // снова копия!
}

void process(std::string); // по значению
```

Нужно снова вызвать `std::move`, если хочешь передать дальше как *rvalue*:
```c++
void take(std::string&& s) {
    process(std::move(s)); // перемещение
}
```

Правило: `std::move` — это обещание, что объект можно "украсть". Но воровать будет только та функция, которая перегружена для *rvalue*.

`std::move` не перемещает объект, а лишь превращает его в rvalue.

Ошибка: Бессмысленный `std::move`
```c++
std::string getString() {
    std::string str = "Hello, world!";
    return std::move(str); // Неэффективно
}
```
Возвращаемый `std::string` и так является временным объектом [[NRVO]], и `std::move` мешает этой оптимизации. В результате компилятор не сможет выполнить перемещение, а вызовет копирование.  

Правильный вариант:
```c++
std::string getString() {
    return "Hello, world!"; // NRVO оптимизация
}
```

Используйте `std::move`, когда точно знаете, что объект больше не нужен и его можно переместить:
```c++
void processString(std::string str) { /* ... */ }

int main() {
    std::string s = "Example";
    processString(std::move(s)); // Теперь перемещение!
}
```

1 Не используйте `std::move` при возврате локальных объектов — дайте компилятору сделать свое дело.
2 Используйте `std::move`, когда объект больше не нужен — это ускорит работу кода.  
3 После `std::move` не используйте переменную, кроме как для присвоения нового значения.  

