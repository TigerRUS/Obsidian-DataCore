[[string_view]] - легковесное «окно» для строк. В C++20 у него появился старший брат для массивов и векторов - `std::span`

До C++20 у нас была классическая проблема. Допустим, вы пишете функцию, которая должна обработать список чисел.

Вариант 1: Принимать `const std::vector<int>&.`
Функция теперь намертво привязана к `std::vector`. Если у вас данные лежат в `std::array` или обычном си-массиве `int arr[10]`, придется копировать их в вектор.

Вариант 2: Си-стайл (Указатель + размер).
Легко ошибиться с размером, потерять контекст, код выглядит грязно.
```c++
void ProcessOld(const int* data, size_t size) { /* ... */ }
```

C++20 `std::span`:
```c++
#include <span>

// Принимаем любой непрерывный кусок памяти!
void ProcessNew(std::span<const int> data) {
    for (int val : data) {
        std::cout << val << " ";
    }
}
```

Что такое `std::span`?
Как и `string_view`, это просто указатель на начало данных и их длина (обычно 16 байт). Он не владеет памятью, он только на нее смотрит.

`std::span` умеет автоматически создаваться из чего угодно:
```c++
std::vector<int> vec = {1, 2, 3};
std::array<int, 3> arr = {4, 5, 6};
int raw[3] = {7, 8, 9};

// Одна функция работает со всеми типами контейнеров! Без копирования!
ProcessNew(vec); 
ProcessNew(arr);
ProcessNew(raw);
```

Суперсила: Subspan (Подмассивы)
Вам нужно передать в функцию только часть вектора, например, со 2-го по 5-й элемент? Никаких итераторов и копирования:

```c++
// Передаем кусок вектора за O(1)
ProcessNew( std::span{vec}.subspan(1, 4) ); 
```

Важный нюанс:
`std::span` не умеет изменять размер данных (никаких `push_back`). Но он может изменять сами элементы, если вы передадите `std::span<int>` (без const).

Итог: Если ваша *функция принимает набор данных только для чтения или изменения элементов на месте*, всегда используйте `std::span`.
Это золотой стандарт современного C++.
