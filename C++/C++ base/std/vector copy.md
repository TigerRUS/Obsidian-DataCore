```c++
std::vector<int> result;
result = getVector();
```

Если `getVector()` возвращает временный объект, то копирование можно избежать, используя `std::move` или Return Value Optimization ([[RVO]]).

Но вот интересное: если вы точно знаете, что копия не нужна, используйте `std::vector::swap` с временным объектом:
```c++
std::vector<int> result;
std::vector<int> tmp = getVector();
result.swap(tmp);
```

Почему это может быть лучше?
-  Быстрая реализация через указатели.
-  Не вызывает лишние аллокаторы.
-  Не зависит от move конструктора.
-  Гарантированно не бросает исключений, если swap noexcept (что обычно так).

В новых компиляторах `result = std::move(tmp)` даст тот же эффект, но `swap` — это старый добрый способ, который работает предсказуемо.