Тонкости STL, которые часто вылетают в продакшн:

1. Инвалидирование итераторов
   При vector::erase все итераторы от позиции удаления до end() становятся «битые». Чтобы безопасно отфильтровать и удалить элементы, пользуйтесь erase–remove идиомой:

```c++
auto it = std::remove_if(v.begin(), v.end(), [](int x){ return x < 0; });
v.erase(it, v.end());
```
   
`remove_if` сдвигает «хвост» вперёд, но не меняет размер контейнера.

2. `reserve vs resize`
   * `v.reserve(n)` выделяет память, но не создаёт объектов → `size()` не меняется, можно безопасно `push_back`.
   * `v.resize(n)` создаёт n элементов, инициализированных значениями по умолчанию.

2. Производительность `std::distance`
   На random-access итераторах (например, vector) это O(1), а на bidirectional или forward (например, list) — O(n). Для списков используйте `size()` (C++11+) или считайте вручную в критичных местах.

3. `emplace_back vs push_back`
   При сложных типах emplace_back может избежать лишнего копирования:

```c++
v.emplace_back(ctor_arg1, ctor_arg2);
// vs
v.push_back(MyType(ctor_arg1, ctor_arg2));
```
   
4. компараторы
   В `set` или `map` компаратор должен задавать строгий-уровень-менее (operator<): если `comp(a,b)== true, то comp(b,a)` обязан быть `false`. Иначе — [[UB]].