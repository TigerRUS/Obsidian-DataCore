`std::optional` и *return value optimization* ([[RVO]])

Когда возвращаешь из функции `std::optional<T>`, часто задумываешься о лишних копиях. Например, вот так:
```c++
std::optional<std::string> make_name(bool valid) {
    if (valid) return "Женя";
    return std::nullopt;
}
```

Миф: здесь всегда будет копирование строки.
Реальность: современные компиляторы отлично оптимизируют этот код благодаря [[RVO]]. Если возвращаемое значение — временный объект, C++ может создать его сразу в том месте, куда он должен быть возвращён. Копий не будет!

Ещё интереснее с C++17: возвращение `{}` для `std::optional<T>` и `"str"` для строки — это всё равно RVO.

Но если возвращаешь существующий объект:
```c++
std::optional<std::string> wrap(const std::string& s) {
    return s; // здесь копия неизбежна
}
```

- тут [[RVO]] не поможет, потому что возвращаешь уже существующий объект, а не временный.

Не бойся возвращать большие объекты через `std::optional`. RVO спасает производительность, когда возвращаешь временные объекты.