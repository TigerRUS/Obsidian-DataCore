**False Sharing** (ложное разделение) — это проблема производительности в многопоточных системах, возникающая, когда разные ядра процессора изменяют независимые данные, которые случайно оказались на одной *кэш-линии*.

Как это работает
1. **Кэш-линия:** Процессор загружает данные из памяти не побайтово, а блоками (обычно по *64 байта*). Этот блок называется кэш-линией.
2. **Протокол когерентности [[MESI]]:** Если ядро №1 меняет байт в своей кэш-линии, эта же линия в кэшах других ядер помечается как невалидная (Invalid).
3. **Конфликт:** Допустим, у нас есть две переменные `A` и `B`. Они лежат рядом и попали в одну кэш-линию. Поток 1 на Ядре 1 меняет `A`, а Поток 2 на Ядре 2 меняет `B`.
4. **Результат:** Хотя логически переменные не связаны, ядра вынуждены постоянно пересылать эту кэш-линию друг другу через общую шину, так как запись в `A` портит всю линию для ядра с переменной `B`. Это приводит к катастрофическому падению скорости.

В этом примере два потока инкрементируют свои счетчики. *Если они лежат в одной структуре рядом, возникнет false sharing*.

```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <atomic>

// Плохая структура: данные лежат слишком близко
struct BadStruct {
    std::atomic<size_t> count1{0}; // 8 байт
    std::atomic<size_t> count2{0}; // 8 байт
    // Итого 16 байт — они гарантированно попадут в одну 64-байтную кэш-линию
};

// Хорошая структура: используем alignment (выравнивание)
struct GoodStruct {
    alignas(64) std::atomic<size_t> count1{0}; 
    alignas(64) std::atomic<size_t> count2{0}; 
    // Теперь каждая переменная занимает свою кэш-линию
};

void work(std::atomic<size_t>& counter) {
    for (int i = 0; i < 100'000'000; ++i) {
        counter.fetch_add(1, std::memory_order_relaxed);
    }
}

int main() {
    BadStruct bad;
    
    auto start = std::chrono::high_resolution_clock::now();
    
    std::thread t1(work, std::ref(bad.count1));
    std::thread t2(work, std::ref(bad.count2));
    t1.join();
    t2.join();
    
    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> diff = end - start;
    
    std::cout << "Time with False Sharing: " << diff.count() << "s" << std::endl;
    return 0;
}
```

Как лечить
1. **`alignas(64)`**: Спецификатор в C++11 и выше, который заставляет компилятор размещать данные по адресу, кратному 64 (начало новой кэш-линии).
2. **`std::hardware_destructive_interference_size`**: В C++17 появилась константа (в заголовке `<new>`), которая точно указывает размер кэш-линии для текущей архитектуры (вместо магического числа 64).
3. **Padding (отступы)**: Добавление «мусорных» полей между полезными данными, чтобы разнести их в разные блоки памяти.
