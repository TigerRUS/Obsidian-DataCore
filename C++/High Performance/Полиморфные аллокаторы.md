Благодаря полиморфным аллокаторам в C++17 можно оптимизировать распределение памяти. Эта оптимизация включает в себя производительность и повторное использование памяти.

https://www.modernescpp.com/index.php/optimization-with-allocators-in-c17/

Полиморфные аллокаторы (**Polymorphic Allocators**, сокращенно **PMR**) появились в стандарте C++17 в заголовочном файле `<memory_resource>`. Они решают проблему жесткой привязки типа контейнера к типу его аллокатора.

**1. Проблема обычных аллокаторов**

В стандартном C++ тип аллокатора является частью типа контейнера:  
`std::vector<int, MyAlloc<int>>` и `std::vector<int, OtherAlloc<int>>` — это *разные типы*. Вы не можете передать их в одну функцию, ожидающую вектор, без использования шаблонов. Это приводит к раздуванию кода (code bloat) и невозможности изменить стратегию памяти во время выполнения.

**2. Суть PMR (std::pmr)**

PMR разделяет интерфейс и реализацию:

1. **`std::pmr::memory_resource`**: Абстрактный базовый класс (интерфейс) с виртуальными методами `do_allocate` и `do_deallocate`.
2. **`std::pmr::polymorphic_allocator<T>`**: Шаблонный класс-обертка, который работает через указатель на `memory_resource`.
3. **Тип контейнера**: Теперь всегда один и тот же. Например, `std::pmr::vector<int>` — это всегда `std::vector<int, std::pmr::polymorphic_allocator<int>>`.

**3. Где здесь оптимизация?**

Главная оптимизация заключается в использовании специальных стратегий управления памятью без изменения кода логики:

- **`monotonic_buffer_resource`**: Выделяет память из заранее подготовленного буфера (на стеке или в куче). Память только "растет" и освобождается целиком при уничтожении ресурса. Это *экстремально быстро*, так как `allocate` — это просто сдвиг указателя.
- **`unsynchronized_pool_resource`**: Пул потокобезопасных (или нет) блоков памяти фиксированного размера. Помогает избежать фрагментации.

**4. Оптимизация с использованием стекового буфера**

Представим ситуацию, где мы в цикле создаем векторы. Обычный вектор каждый раз будет вызывать медленные `new` и `delete`. С PMR мы можем использовать память на стеке, что является Blazing fast

```cpp
#include <iostream>
#include <vector>
#include <memory_resource> // Заголовок для PMR
#include <array>

int main() {
    // 1. Создаем буфер на стеке (очень быстро)
    std::array<std::byte, 1024> stack_buffer;

    // 2. Создаем ресурс, который будет использовать этот буфер
    // Если 1024 байт не хватит, он обратится к new_delete_resource() по умолчанию
    std::pmr::monotonic_buffer_resource pool{stack_buffer.data(), stack_buffer.size()};

    // 3. Создаем вектор, использующий наш полиморфный ресурс
    // Обратите внимание на тип: std::pmr::vector
    std::pmr::vector<int> v{&pool};

    // Эти операции не вызывают системный аллокатор кучи!
    // Данные размещаются прямо в stack_buffer.
    for (int i = 0; i < 10; ++i) {
        v.push_back(i);
    }

    for (int n : v) {
        std::cout << n << " ";
    }

    return 0;
} // Здесь уничтожается pool, и вся память освобождается разом.
```

Преимущества данного подхода:
1. **Локальность данных**: Данные вектора лежат на стеке, что ускоряет работу кэша процессора.
2. **Отсутствие блокировок**: Системный `malloc` часто использует мьютексы. С `monotonic_buffer_resource` в одном потоке блокировок нет.
3. **Гибкость**: Вы можете написать функцию `process(std::pmr::vector<int>& v)` и передавать туда векторы, которые используют разные ресурсы (стек, кучу, файлы, отображаемые в память), не перекомпилируя функцию.
