*Выравнивание памяти* — это расположение данных в памяти по адресам, кратным размеру данных (например, `int` по адресу, кратному 4 байтам), что ускоряет доступ процессора, который работает с машинными словами; это достигается неявным добавлением "пустых" байтов (padding) в структуры и классы, но может быть изменено с помощью директив компилятора, таких как `__attribute__((aligned))` или `#pragma pack`, для оптимизации памяти или совместимости с аппаратным обеспечением. 

1. Почему выравнивание важно
- **Производительность**: Процессоры быстрее читают данные, если они выровнены (например, 4 байта по адресу, кратному 4), избегая нескольких обращений к памяти.
- **Аппаратные требования**: Некоторые архитектуры требуют строгого выравнивания, иначе программа может аварийно завершиться (Segmentation Fault). 

2. Как это работает
```cpp
struct MyData {
    char c; // 1 байт
    int i;  // 4 байта
};
```

- **Без выравнивания:** `c` (1 байт) + `i` (4 байта) = 5 байт.
- **С выравниванием (типично)**: Компилятор добавит 3 байта "пустоты" (padding) после `c`, чтобы `i` начался с адреса, кратного 4, сделав размер структуры 8 байт (1 + 3 + 4). 

3. Как управлять выравниванием
- **Неявное (автоматическое)**: Компилятор управляет этим сам. Переупорядочивание полей структуры (сначала большие, потом маленькие) может уменьшить padding.
- **Явное (директивы компилятора)**:
    - `__attribute__((aligned(N)))`: Для GCC/Clang (например, `__attribute__((aligned(16)))`).
    - `__declspec(align(N))`: Для MSVC (например, `__declspec(align(16))`).
    - `#pragma pack(N)`: Для установки упаковки (например, `#pragma pack(1)` для полного отсутствия padding). 

4. Когда это нужно
- **Встраивание в аппаратные регистры**: При работе с драйверами или низкоуровневым кодом.
- **Сетевые протоколы/Файловые форматы**: Когда структура должна соответствовать определенному формату.
- **Оптимизация памяти**: Если экономия памяти критична, можно использовать `#pragma pack(1)` и жертвовать производительностью.

5. Как проверить выравнивание
- Используйте `sizeof(MyStruct)` для общего размера.
- Используйте `alignof(MyStruct)` (C++11+) для получения размера выравнивания.
- Проверяйте адреса полей с помощью `&myStruct.field1`, `&myStruct.field2` для понимания padding.

---

Поэтому компиляторы языка программирования C (да и большинства других тоже) проводят такую оптимизацию: *между полями структуры вставляются незначащие байты для того, чтобы у всех полей было хорошее выравнивание*.

Пример: для такой структуры:
```cpp
struct
{
    char x; // 1 байт
    int y;  // 4 байта
    char z; // 1 байт
};
```

память выделяется так:
```cpp
[    ] [    ] [    ] [    ] [    ] [    ] [    ] [    ] [    ] [    ] [    ] [    ]
[  x ] { потерянные байты } [             y           ] [  z ] { потерянные байты }
```

Если сама структура будет выровнена в памяти (об этом компилятор тоже заботится), то `y` будет выровнено, и доступ к нему будет быстрым (а на некоторых платформах, напомню, вообще только в этом случае возможен).

Но в этом случае наша структура занимает больше памяти, чем если бы порядок переменных был таким:
```cpp
[    ] [    ] [    ] [    ] [    ] [    ] [    ] [    ]
[  x ] [  z ] {  потеряно } [             y           ]
```

Бóльшая структура означает бóльший расход памяти и бóльшие затраты на копирование, чтение этой структуры и тому подобное. Таким образом, *переставив поля структуры, мы можем сэкономить.*

---

*Выравнивание памяти* объязательно нужно для:
- для выполнения [[SIMD]] (Single Instruction Multiple Data)
- для атомарных операций ([[atomics]])

