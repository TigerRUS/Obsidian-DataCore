1. *Универсальная замена assert в runtime-среде:*
```c++
void assert_or_throw(bool cond, const std::string& msg) {
    if (!cond) throw std::runtime_error(msg);
}
```

2. *Преобразование чисел с точностью:*
```c++
template<typename T>
std::string to_string_precise(const T& val, int precision = 6) {
    std::ostringstream out;
    out << std::fixed << std::setprecision(precision) << val;
    return out.str();
}
```

3. *RAII-функция для отложенного вызова:*
```c++
template<typename F>
class ScopeExit {
    F func;
    bool active = true;
public:
    ScopeExit(F&& f) : func(std::forward<F>(f)) {}
    ~ScopeExit() { if (active) func(); }
    void dismiss() { active = false; }
};

template<typename F>
ScopeExit<F> scope_exit(F&& f) {
    return ScopeExit<F>(std::forward<F>(f));
}
```


4. *Компилируемая проверка степени двойки:*
```c++
template<typename T>
constexpr bool is_power_of_two(T x) {
    return x > 0 && (x & (x - 1)) == 0;
}
```

5. *Для реализации собственного std::hash:*
```c++
template<typename T>
void hash_combine(std::size_t& seed, const T& val) {
    seed ^= std::hash<T>()(val) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
}
```

6. *Полезна для парсинга CSV и логов:*
```c++
std::vector<std::string> split(const std::string& str, char delimiter) {
    std::vector<std::string> out;
    std::istringstream ss(str);
    std::string token;
    while (std::getline(ss, token, delimiter)) {
        out.push_back(token);
    }
    return out;
}
```

7. *Ручной аналог std::clamp (если нужна совместимость со старым C++):*
```c++
template<typename T>
T clamp(T val, T min_val, T max_val) {
    return std::max(min_val, std::min(val, max_val));
}
```

8. *Упрощённая обёртка над std::any_of:*
```c++
template<typename Container, typename Predicate>
bool any_of(const Container& c, Predicate pred) {
    return std::any_of(c.begin(), c.end(), pred);
}
```

9. *Интерфейс к std::format (C++20+):*
```c++
template<typename... Args>
std::string format(const std::string& fmt, Args&&... args) {
    return std::vformat(fmt, std::make_format_args(args...));
}
```

10. *Получение имени типа на этапе компиляции:*
```c++
template<typename T>
std::string type_name() {
#ifdef __clang__
    std::string name = __PRETTY_FUNCTION__;
    return name.substr(31, name.length() - 32);
#elif defined(__GNUC__)
    std::string name = __PRETTY_FUNCTION__;
    return name.substr(49, name.length() - 50);
#elif defined(_MSC_VER)
    std::string name = __FUNCSIG__;
    return name.substr(38, name.length() - 45);
#else
    return "unknown";
#endif
}
```