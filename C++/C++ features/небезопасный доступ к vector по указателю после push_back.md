```c++
std::vector<MyStruct> vec;
vec.reserve(10); // вроде как "гарантируем", что ничего не сломается

MyStruct* ptr = &vec[0];
vec.push_back(MyStruct{});

// BOOM! ptr теперь может быть невалиден
```

Несмотря на reserve(10), контейнер имеет право перераспределить память при любом `push_back`, если по каким-то причинам решил, что нужно. Например, при нарушении *alignment* или *внутренней оптимизации*.

Что делать безопасно:
* **Никогда не храните указатели или ссылки** на элементы `std::vector`, если планируете его изменять.
* Если нужно, используйте индекс:

```c++
size_t index = 0;
vec.push_back(...);
use(vec[index]);
```

* Или используйте `std::list` или `std::deque`, если вам действительно нужны устойчивые указатели.

Это классический источник [[UB]], особенно в старых проектах, где кто-то “оптимизировал” память, сохранив указатель.